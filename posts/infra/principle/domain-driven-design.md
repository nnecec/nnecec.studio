---
title: '领域驱动模型（Domain-Driven Design）驱动的前端架构设计和实践'
date: '2024-10-28'
tags: ['Introduction']
description: ''
status: 0
---

## 参考

1. [领域驱动设计在前端中的应用](https://github.com/Vincedream/ddd-fe-demo)
2. [React 语境下前端 DDD 的思考](https://www.tangshuang.net/8212.html)
3. [基于 DDD 的前端项目架构设计与实战](https://www.tangshuang.net/8663.html)
4. [Awesome Domain-Driven Design](https://github.com/heynickc/awesome-ddd)
5. [Domain-Driven Hexagon](https://github.com/Sairyss/domain-driven-hexagon)

## DDD 的心智模型

DDD 是一种设计思想，在业务领域中

- 统一术语
- 一个系统中，一个领域可以分为多个子域，子域还能分为多个子域。
- 核心域、支撑域、通用域
  - 核心域即系统所关联业务的核心部分
  - 支撑域是围绕核心业务的其他附属业务部分
  - 通用域是可能与业务无强相关单需要作为系统的一部分，例如系统中的登录、用户、权限等等，这些领域在行
    业有通用解决方案，同时在本系统中可能存在某些特殊性，但是它们与我们的核心业务相隔甚远，但又必须存
    在

领域的边界通过限界上下文（Bound Context）来定义。限界上下文防腐是指在确定映射之后，通过技术手段在限
界上下文之间设置防腐层，避免由于它们之间的依赖关系，导致过度的耦合。

## 前端工程中的 DDD

在这个场景下，前端和后端的最大不同在于，前端没有后端需要的数据库、服务、系统环境、网络协议等等，但比
后端多出界面和交互部分。因此，前后端的架构设计在遵循 DDD 理念时，实际是有出入的，不能用后端的设计思
维去对照前端。

- 基于微前端的业务模块拆分，从底到顶的去把一个业务模块构建出来。底，就是领域模型，顶就是该业务模块所
  呈现出来的界面，中间需要控制层作为连接，使整个业务模块呈现出较为独立的，能在自己的限界上下文完成自
  己业务全部的模块。
- 基于构建工具链的聚合应用和多端分发

  1. 用户界面层
  2. 应用层
  3. 领域层
  4. 基础设施层

- 领域层代码

  我们需要抽象出只负责业务部分的领域层代码，这一层的代码只描述业务，不考虑界面交互，甚至和真正的应用
  没有任何联系。这也就意味着这部分代码是完全可复用的，是不需要考虑平台、端的。

## 名词解读

- 贫血模型：只包含数据不含业务逻辑的类，叫 贫血模型（Anemic Domain Model）
- 充血模型：数据结构和业务逻辑被封装到同一个类中，满足面向对象的封装性，是典型的面向对象编程风格。​
- 实体 Entity：基于充血模型构建实体模型。
- 服务 Service：通过服务获取服务端数据。
- 业务工厂 Business Factory：通过业务工厂创建业务对象。
- 业务聚合 Business Aggregate：通过业务聚合创建业务对象。

## 实战

1. 确定限界上下文
2. 构建领域模型：对所有业务对象、行为、关联进行领域建模
   1. 实体
   2. 服务
   3. 逻辑
3. 应用分层架构：自下而上分为基础设施层、领域层、应用层、用户界面层
   1. 领域层+应用层，组成了有关业务的全部。
4. 代码模型设计
   - core 用于提供最底层响应式编程驱动的框架实现，需要提供建模、路由、多端同构等一系列系统能力的最底
     层代码
   - libs 基础层的一些实现，主要是第三方的封装和自建的一些工具
   - subjects 按照大的领域概念进行划分后的领域，包括核心域、支撑域和通用域的全部
   - components 基础层的逻辑组件，以及 UI 组件的抽象（UI 组件需要依赖不同端，其实现在各自端实现）
   - hooks 通用的逻辑 hooks 函数
   - modules 应用层业务模块的具体实现
   - @implements 不同端的具体实现，以孤岛代码形式进行原型链侵入
   - apps 用户界面层的应用
5. 构建交互模型
6. 实现交互界面
